{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ES Translator","text":"<p>A lazy yet bulletproof machine translation tool for Elasticsearch.</p>"},{"location":"#installation-ubuntu","title":"Installation (Ubuntu)","text":"<p>Install Apertium:</p> <pre><code>wget https://apertium.projectjj.com/apt/install-nightly.sh -O - | sudo bash\nsudo apt install apertium-all-dev\n</code></pre> <p>Then install es-translator with pip:</p> <pre><code>python3 -m pip install --user es-translator\n</code></pre>"},{"location":"#installation-docker","title":"Installation (Docker)","text":"<p>Nothing to do as long as you have Docker on your system:</p> <pre><code>docker run -it icij/es-translator es-translator --help\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<pre><code>Usage: es-translator [OPTIONS]\n\nOptions:\n  -u, --url TEXT                  Elasticsearch URL\n  -i, --index TEXT                Elasticsearch Index\n  -r, --interpreter TEXT          Interpreter to use to perform the\n                                  translation\n  -s, --source-language TEXT      Source language to translate from\n                                  [required]\n  -t, --target-language TEXT      Target language to translate to  [required]\n  --intermediary-language TEXT    An intermediary language to use when no\n                                  translation is available between the source\n                                  and the target. If none is provided this\n                                  will be calculated automatically.\n  --source-field TEXT             Document field to translate\n  --target-field TEXT             Document field where the translations are\n                                  stored\n  -q, --query-string TEXT         Search query string to filter result\n  -d, --data-dir PATH             Path to the directory where the language\n                                  model will be downloaded\n  --scan-scroll TEXT              Scroll duration (set to higher value if\n                                  you're processing a lot of documents)\n  --dry-run                       Don't save anything in Elasticsearch\n  -f, --force                     Override existing translation in\n                                  Elasticsearch\n  --pool-size INTEGER             Number of parallel processes to start\n  --pool-timeout INTEGER          Timeout to add a translation\n  --throttle INTEGER              Throttle between each translation (in ms)\n  --syslog-address TEXT           Syslog address\n  --syslog-port INTEGER           Syslog port\n  --syslog-facility TEXT          Syslog facility\n  --stdout-loglevel TEXT          Change the default log level for stdout\n                                  error handler\n  --progressbar / --no-progressbar\n                                  Display a progressbar\n  --plan                          Plan translations into a queue instead of\n                                  processing them now\n  --broker-url TEXT               Celery broker URL (only needed when planning\n                                  translation)\n  --max-content-length TEXT       Max translated content length\n                                  (&lt;[0-9]+[KMG]?&gt;) to avoid highlight\n                                  errors(see http://github.com/ICIJ/datashare/\n                                  issues/1184)\n  --help                          Show this message and exit.\n</code></pre> <p>Learn more about how to use this command in the Usage Documentation.</p>"},{"location":"#api","title":"API","text":"<p>The documentation is generated from the docstrings in the code using the <code>mkdocstrings</code> plugin. It provides detailed information about the classes, methods, and attributes in the EsTranslator library.</p> <p>You can explore the API Documentation for more information.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! If you encounter any issues or have suggestions for improvements, please open an issue on the GitHub repository. If you're willing to help, check the page about how to contribute to this project.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License. See the LICENSE file for more details.</p>"},{"location":"api/","title":"API Reference","text":"<p>Welcome to the API reference for EsTranslator. This section provides detailed information about the classes, methods, and attributes available in the EsTranslator library.</p>"},{"location":"api/#core","title":"Core","text":""},{"location":"api/#es_translator.EsTranslator","title":"es_translator.EsTranslator","text":"<pre><code>EsTranslator(options)\n</code></pre> <p>Orchestrates translation of Elasticsearch documents.</p> <p>Manages the translation workflow including searching for documents, parallel translation using worker pools, and updating translated documents.</p> <p>Attributes:</p> Name Type Description <code>url</code> <p>Elasticsearch URL.</p> <code>index</code> <p>Index name to search and update.</p> <code>source_language</code> <p>Source language code.</p> <code>target_language</code> <p>Target language code.</p> <code>intermediary_language</code> <p>Optional intermediary language for indirect translation.</p> <code>source_field</code> <p>Field name containing source text.</p> <code>target_field</code> <p>Field name to store translated text.</p> <code>query_string</code> <p>Optional Elasticsearch query string.</p> <code>data_dir</code> <p>Directory for storing interpreter data.</p> <code>scan_scroll</code> <p>Scroll timeout for search.</p> <code>dry_run</code> <p>If True, skip saving translated documents.</p> <code>force</code> <p>Force re-translation of already translated documents.</p> <code>pool_size</code> <p>Number of parallel worker processes.</p> <code>pool_timeout</code> <p>Timeout for worker pool operations.</p> <code>throttle</code> <p>Throttle for rate limiting.</p> <code>progressbar</code> <p>Show progress bar during translation.</p> <code>interpreter_name</code> <p>Name of translation interpreter to use.</p> <code>max_content_length</code> <p>Maximum content length to translate (-1 for unlimited).</p> <code>plan</code> <p>If True, queue translations for later execution.</p> <code>interpreter</code> <p>Instantiated interpreter instance.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>dict[str, Any]</code> <p>Dictionary of configuration options.</p> required Source code in <code>es_translator/es_translator.py</code> <pre><code>def __init__(self, options: dict[str, Any]) -&gt; None:\n    \"\"\"Initialize the Elasticsearch translator.\n\n    Args:\n        options: Dictionary of configuration options.\n    \"\"\"\n    self.url = options['url']\n    self.index = options['index']\n    self.source_language = options['source_language']\n    self.target_language = options['target_language']\n    self.intermediary_language = options['intermediary_language']\n    self.source_field = options['source_field']\n    self.target_field = options['target_field']\n    self.query_string = options['query_string']\n    self.data_dir = options['data_dir']\n    self.scan_scroll = options['scan_scroll']\n    self.dry_run = options.get('dry_run', False)\n    self.force = options['force']\n    self.pool_size = options['pool_size']\n    self.pool_timeout = options['pool_timeout']\n    self.throttle = options['throttle']\n    self.progressbar = options.get('progressbar', False)\n    self.interpreter_name = options['interpreter']\n    self.max_content_length = options.get('max_content_length', -1)\n    self.plan = options.get('plan', False)\n</code></pre>"},{"location":"api/#es_translator.EsTranslator.no_progressbar","title":"no_progressbar  <code>property</code>","text":"<pre><code>no_progressbar\n</code></pre> <p>Check if the progressbar option is set to False.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the progressbar option is False, else False.</p>"},{"location":"api/#es_translator.EsTranslator.options","title":"options  <code>property</code>","text":"<pre><code>options\n</code></pre> <p>Get configuration options as a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary containing all configuration options.</p>"},{"location":"api/#es_translator.EsTranslator.search_source","title":"search_source  <code>property</code>","text":"<pre><code>search_source\n</code></pre> <p>Gets the list of fields to use in the search.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List[str]: list of fields to use in the search.</p>"},{"location":"api/#es_translator.EsTranslator.stdout_loglevel","title":"stdout_loglevel  <code>property</code>","text":"<pre><code>stdout_loglevel\n</code></pre> <p>Gets the log level of stdout.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The log level of stdout.</p>"},{"location":"api/#es_translator.EsTranslator.configure_search","title":"configure_search","text":"<pre><code>configure_search()\n</code></pre> <p>Configures the search object.</p> <p>Returns:</p> Name Type Description <code>Search</code> <code>Search</code> <p>A configured search object.</p> Source code in <code>es_translator/es_translator.py</code> <pre><code>def configure_search(self) -&gt; Search:\n    \"\"\"Configures the search object.\n\n    Returns:\n        Search: A configured search object.\n    \"\"\"\n    search = self.search()\n    search = search.source(self.search_source)\n    search = search.params(scroll=self.scan_scroll, size=self.pool_size)\n    return search\n</code></pre>"},{"location":"api/#es_translator.EsTranslator.create_client","title":"create_client","text":"<pre><code>create_client()\n</code></pre> <p>Create an Elasticsearch client instance.</p> <p>Returns:</p> Type Description <code>Elasticsearch</code> <p>Configured Elasticsearch client.</p> Source code in <code>es_translator/es_translator.py</code> <pre><code>def create_client(self) -&gt; Elasticsearch:\n    \"\"\"Create an Elasticsearch client instance.\n\n    Returns:\n        Configured Elasticsearch client.\n    \"\"\"\n    return Elasticsearch(self.url)\n</code></pre>"},{"location":"api/#es_translator.EsTranslator.create_translated_hit","title":"create_translated_hit","text":"<pre><code>create_translated_hit(hit)\n</code></pre> <p>Create a TranslatedHit wrapper for a document hit.</p> <p>Parameters:</p> Name Type Description Default <code>hit</code> <code>ObjectBase</code> <p>Document hit object.</p> required <p>Returns:</p> Type Description <code>TranslatedHit</code> <p>TranslatedHit instance ready for translation.</p> Source code in <code>es_translator/es_translator.py</code> <pre><code>def create_translated_hit(self, hit: ObjectBase) -&gt; TranslatedHit:\n    \"\"\"Create a TranslatedHit wrapper for a document hit.\n\n    Args:\n        hit: Document hit object.\n\n    Returns:\n        TranslatedHit instance ready for translation.\n    \"\"\"\n    return TranslatedHit(hit, self.source_field, self.target_field, self.force)\n</code></pre>"},{"location":"api/#es_translator.EsTranslator.create_translation_queue","title":"create_translation_queue","text":"<pre><code>create_translation_queue()\n</code></pre> <p>Creates a queue that can translate documents in parallel.</p> <p>Returns:</p> Name Type Description <code>JoinableQueue</code> <code>JoinableQueue</code> <p>A queue for parallel document translation.</p> Source code in <code>es_translator/es_translator.py</code> <pre><code>def create_translation_queue(self) -&gt; JoinableQueue:\n    \"\"\"Creates a queue that can translate documents in parallel.\n\n    Returns:\n        JoinableQueue: A queue for parallel document translation.\n    \"\"\"\n    return JoinableQueue(self.pool_size)\n</code></pre>"},{"location":"api/#es_translator.EsTranslator.find_document","title":"find_document","text":"<pre><code>find_document(params)\n</code></pre> <p>Find a document by ID and routing.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict[str, str]</code> <p>Dictionary containing 'index', 'id', and optionally 'routing'.</p> required <p>Returns:</p> Type Description <code>Document</code> <p>The found Document object.</p> Source code in <code>es_translator/es_translator.py</code> <pre><code>def find_document(self, params: dict[str, str]) -&gt; Document:\n    \"\"\"Find a document by ID and routing.\n\n    Args:\n        params: Dictionary containing 'index', 'id', and optionally 'routing'.\n\n    Returns:\n        The found Document object.\n    \"\"\"\n    using = self.create_client()\n    routing = getattr(params, 'routing', params['id'])\n    return Document.get(\n        index=params['index'],\n        id=params['id'],\n        routing=routing,\n        using=using)\n</code></pre>"},{"location":"api/#es_translator.EsTranslator.init_interpreter","title":"init_interpreter","text":"<pre><code>init_interpreter()\n</code></pre> <p>Initializes the interpreter.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The initialized interpreter.</p> Source code in <code>es_translator/es_translator.py</code> <pre><code>def init_interpreter(self) -&gt; Any:\n    \"\"\"Initializes the interpreter.\n\n    Returns:\n        Any: The initialized interpreter.\n    \"\"\"\n    pack_dir = path.join(self.data_dir, 'packs', self.interpreter_name)\n    interpreters = (Apertium, Argos,)\n    Interpreter = next(\n        i for i in interpreters if i.name.lower() == self.interpreter_name.lower())\n    return Interpreter(\n        self.source_language,\n        self.target_language,\n        self.intermediary_language,\n        pack_dir)\n</code></pre>"},{"location":"api/#es_translator.EsTranslator.instantiate_interpreter","title":"instantiate_interpreter","text":"<pre><code>instantiate_interpreter()\n</code></pre> <p>Instantiates the interpreter.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>An instance of the interpreter.</p> Source code in <code>es_translator/es_translator.py</code> <pre><code>def instantiate_interpreter(self) -&gt; Any:\n    \"\"\"Instantiates the interpreter.\n\n    Returns:\n        Any: An instance of the interpreter.\n    \"\"\"\n    if not hasattr(self, 'interpreter'):\n        with self.print_done(f'Instantiating {self.interpreter_name} interpreter'):\n            self.interpreter = self.init_interpreter()\n    return self.interpreter\n</code></pre>"},{"location":"api/#es_translator.EsTranslator.print_done","title":"print_done","text":"<pre><code>print_done(string)\n</code></pre> <p>Print progress message and yield, showing done/error status.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The status message to be printed.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Generator for wrapping operations with status output.</p> Source code in <code>es_translator/es_translator.py</code> <pre><code>@contextmanager\ndef print_done(self, string: str) -&gt; Generator[None, None, None]:\n    \"\"\"Print progress message and yield, showing done/error status.\n\n    Args:\n        string: The status message to be printed.\n\n    Returns:\n        Generator for wrapping operations with status output.\n    \"\"\"\n    logger.info(string)\n    if self.stdout_loglevel &gt; 20:\n        string = f'\\r{string}...'\n        self.print_flush(string)\n        try:\n            yield\n            print(f'{string} \\033[92mdone\\033[0m')\n        except (FatalTranslationException, ElasticsearchException, Full) as error:\n            logger.error(error, exc_info=True)\n            print(f'{string} \\033[91merror\\033[0m')\n            sys.exit(1)\n    else:\n        yield\n</code></pre>"},{"location":"api/#es_translator.EsTranslator.print_flush","title":"print_flush","text":"<pre><code>print_flush(string)\n</code></pre> <p>Print and flush a string to stdout.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The string to be printed.</p> required Source code in <code>es_translator/es_translator.py</code> <pre><code>def print_flush(self, string: str) -&gt; None:\n    \"\"\"Print and flush a string to stdout.\n\n    Args:\n        string: The string to be printed.\n    \"\"\"\n    sys.stdout.write(f'\\r{string}')\n    sys.stdout.flush()\n</code></pre>"},{"location":"api/#es_translator.EsTranslator.process_document","title":"process_document","text":"<pre><code>process_document(\n    translation_queue,\n    hit,\n    progress,\n    task,\n    shared_fatal_error,\n)\n</code></pre> <p>Processes a document.</p> <p>Parameters:</p> Name Type Description Default <code>translation_queue</code> <code>JoinableQueue</code> <p>A queue for parallel document translation.</p> required <code>hit</code> <code>Any</code> <p>The document to be translated.</p> required <code>index</code> <code>int</code> <p>The index of the document.</p> required <code>progress</code> <code>Progress</code> <p>A progress object.</p> required <code>task</code> <code>Any</code> <p>The current task.</p> required <code>shared_fatal_error</code> <code>Manager</code> <p>A shared manager for fatal errors.</p> required Source code in <code>es_translator/es_translator.py</code> <pre><code>def process_document(\n        self,\n        translation_queue: JoinableQueue,\n        hit: Any,\n        progress: Progress,\n        task: Any,\n        shared_fatal_error: Manager) -&gt; None:\n    \"\"\"Processes a document.\n\n    Args:\n        translation_queue (JoinableQueue): A queue for parallel document translation.\n        hit (Any): The document to be translated.\n        index (int): The index of the document.\n        progress (Progress): A progress object.\n        task (Any): The current task.\n        shared_fatal_error (Manager): A shared manager for fatal errors.\n    \"\"\"\n    translation_queue.put((self, hit), True, self.pool_timeout)\n    progress.advance(task)\n    if shared_fatal_error.value:\n        raise FatalTranslationException(shared_fatal_error.value)\n</code></pre>"},{"location":"api/#es_translator.EsTranslator.search","title":"search","text":"<pre><code>search()\n</code></pre> <p>Executes a search query.</p> <p>Returns:</p> Name Type Description <code>Search</code> <code>Search</code> <p>The search result.</p> Source code in <code>es_translator/es_translator.py</code> <pre><code>def search(self) -&gt; Search:\n    \"\"\"Executes a search query.\n\n    Returns:\n        Search: The search result.\n    \"\"\"\n    using = self.create_client()\n    search = Search(index=self.index, using=using)\n    if self.query_string:\n        search = search.query(\"query_string\", query=self.query_string)\n    return search\n</code></pre>"},{"location":"api/#es_translator.EsTranslator.start","title":"start","text":"<pre><code>start()\n</code></pre> <p>Starts or plans the translation process.</p> Source code in <code>es_translator/es_translator.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Starts or plans the translation process.\"\"\"\n    if self.plan:\n        self.start_later()\n    else:\n        self.start_now()\n</code></pre>"},{"location":"api/#es_translator.EsTranslator.start_later","title":"start_later","text":"<pre><code>start_later()\n</code></pre> <p>Queue translation tasks for later execution via Celery.</p> Source code in <code>es_translator/es_translator.py</code> <pre><code>def start_later(self) -&gt; None:\n    \"\"\"Queue translation tasks for later execution via Celery.\"\"\"\n    self.instantiate_interpreter()\n    total = self.search().count()\n    desc = f\"Planning translation for {total} document{'s'[:total^1]}\"\n    with self.print_done(desc):\n        search = self.configure_search()\n        for hit in search.scan():\n            logger.info(f'Planned translation for doc {hit.meta.id}')\n            translate_document_task.delay(self.options, hit.meta.to_dict())\n</code></pre>"},{"location":"api/#es_translator.EsTranslator.start_now","title":"start_now","text":"<pre><code>start_now()\n</code></pre> <p>Start the translation process immediately.</p> Source code in <code>es_translator/es_translator.py</code> <pre><code>def start_now(self) -&gt; None:\n    \"\"\"Start the translation process immediately.\"\"\"\n    self.instantiate_interpreter()\n    total = self.search().count()\n    desc = f'Translating {total} document(s)'\n    with self.print_done(desc):\n        search = self.configure_search()\n        translation_queue = self.create_translation_queue()\n        with self.with_shared_fatal_error() as shared_fatal_error:\n            self.translate_documents_in_pool(\n                search, translation_queue, shared_fatal_error, total)\n</code></pre>"},{"location":"api/#es_translator.EsTranslator.translate_document","title":"translate_document","text":"<pre><code>translate_document(hit)\n</code></pre> <p>Translate a single document.</p> <p>Parameters:</p> Name Type Description Default <code>hit</code> <code>ObjectBase</code> <p>Document hit object to translate.</p> required Source code in <code>es_translator/es_translator.py</code> <pre><code>def translate_document(self, hit: ObjectBase) -&gt; None:\n    \"\"\"Translate a single document.\n\n    Args:\n        hit: Document hit object to translate.\n    \"\"\"\n    self.instantiate_interpreter()\n    # Translate the document\n    logger.info(f'Translating doc {hit.meta.id}')\n    translated_hit = self.create_translated_hit(hit)\n    translated_hit.add_translation(self.interpreter, max_content_length=self.max_content_length)\n    logger.info(f'Translated doc {hit.meta.id}')\n    # Save the translated document if not in dry run mode\n    if not self.dry_run:\n        translated_hit.save(self.create_client())\n        logger.info(f'Saved translation for doc {hit.meta.id}')\n</code></pre>"},{"location":"api/#es_translator.EsTranslator.translate_documents_in_pool","title":"translate_documents_in_pool","text":"<pre><code>translate_documents_in_pool(\n    search, translation_queue, shared_fatal_error, total\n)\n</code></pre> <p>Translates documents.</p> <p>Parameters:</p> Name Type Description Default <code>search</code> <code>Search</code> <p>A search object.</p> required <code>translation_queue</code> <code>JoinableQueue</code> <p>A queue for parallel document translation.</p> required <code>shared_fatal_error</code> <code>Manager</code> <p>A shared manager for fatal errors.</p> required <code>total</code> <code>int</code> <p>The total number of documents.</p> required Source code in <code>es_translator/es_translator.py</code> <pre><code>def translate_documents_in_pool(\n        self,\n        search: Search,\n        translation_queue: JoinableQueue,\n        shared_fatal_error: Manager,\n        total: int) -&gt; None:\n    \"\"\"Translates documents.\n\n    Args:\n        search (Search): A search object.\n        translation_queue (JoinableQueue): A queue for parallel document translation.\n        shared_fatal_error (Manager): A shared manager for fatal errors.\n        total (int): The total number of documents.\n    \"\"\"\n    with (\n        Pool(self.pool_size, translation_worker, (translation_queue, shared_fatal_error)),\n        Progress(disable=self.no_progressbar, transient=True) as progress,\n    ):\n        task = progress.add_task(\n            f\"Translating {total} document{'s'[:total^1]}\", total=total)\n        for hit in search.scan():\n            self.process_document(\n                translation_queue, hit, progress, task, shared_fatal_error)\n        translation_queue.join()\n</code></pre>"},{"location":"api/#es_translator.EsTranslator.with_shared_fatal_error","title":"with_shared_fatal_error","text":"<pre><code>with_shared_fatal_error()\n</code></pre> <p>Creates a context manager for managing shared fatal errors.</p> <p>Returns:</p> Type Description <code>None</code> <p>Generator yielding a shared manager value.</p> Source code in <code>es_translator/es_translator.py</code> <pre><code>@contextmanager\ndef with_shared_fatal_error(self) -&gt; Generator[Any, None, None]:\n    \"\"\"Creates a context manager for managing shared fatal errors.\n\n    Returns:\n        Generator yielding a shared manager value.\n    \"\"\"\n    with Manager() as manager:\n        yield manager.Value('b', None)\n</code></pre>"},{"location":"api/#interpreters","title":"Interpreters","text":"<p>EsTranslator supports multiple translation backends (interpreters). Each interpreter has its own strengths and supported language pairs.</p>"},{"location":"api/#argos","title":"Argos","text":"<p>Argos Translate is a neural machine translation library that provides high-quality translations using offline models.</p>"},{"location":"api/#es_translator.interpreters.Argos","title":"es_translator.interpreters.Argos","text":"<pre><code>Argos(\n    source=None,\n    target=None,\n    intermediary=None,\n    pack_dir=None,\n)\n</code></pre> <p>               Bases: <code>AbstractInterpreter</code></p> <p>Argos translation interpreter using argostranslate.</p> <p>This class handles translation tasks using the Argos neural machine translation engine. Note that Argos does not support intermediary languages or custom package directories.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>Identifier for this interpreter ('ARGOS').</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Optional[str]</code> <p>Source language code.</p> <code>None</code> <code>target</code> <code>Optional[str]</code> <p>Target language code.</p> <code>None</code> <code>intermediary</code> <code>Optional[str]</code> <p>Intermediary language code (not supported, will warn if provided).</p> <code>None</code> <code>pack_dir</code> <code>Optional[str]</code> <p>Directory for language packs (not supported, will warn if provided).</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If the necessary language pair is not available.</p> Source code in <code>es_translator/interpreters/argos/argos.py</code> <pre><code>def __init__(\n        self,\n        source: Optional[str] = None,\n        target: Optional[str] = None,\n        intermediary: Optional[str] = None,\n        pack_dir: Optional[str] = None) -&gt; None:\n    \"\"\"Initialize the Argos interpreter.\n\n    Args:\n        source: Source language code.\n        target: Target language code.\n        intermediary: Intermediary language code (not supported, will warn if provided).\n        pack_dir: Directory for language packs (not supported, will warn if provided).\n\n    Raises:\n        Exception: If the necessary language pair is not available.\n    \"\"\"\n    super().__init__(source, target)\n    # Raise an exception if an intermediary language is provided\n    if intermediary is not None:\n        logger.warn(\n            'Argos interpreter does not support intermediary language')\n    if pack_dir is not None:\n        logger.warn(\n            'Argos interpreter does not support custom pack directory')\n    # Raise an exception if the language pair is unknown\n    if not self.is_pair_available and self.has_pair:\n        try:\n            self.download_necessary_languages()\n        except ArgosPairNotAvailable:\n            raise Exception(f'The pair {self.pair} is not available')\n    else:\n        logger.info(f'Existing package(s) found for pair {self.pair}')\n</code></pre>"},{"location":"api/#es_translator.interpreters.Argos.is_pair_available","title":"is_pair_available  <code>property</code>","text":"<pre><code>is_pair_available\n</code></pre> <p>Check if the necessary language pair is available in installed packages.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the language pair is available, False otherwise.</p>"},{"location":"api/#es_translator.interpreters.Argos.local_languages","title":"local_languages  <code>property</code>","text":"<pre><code>local_languages\n</code></pre> <p>Get the codes for the installed languages.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of installed language codes. Returns empty list if languages cannot be retrieved.</p>"},{"location":"api/#es_translator.interpreters.Argos.translation","title":"translation  <code>property</code>","text":"<pre><code>translation\n</code></pre> <p>Get Translation object for the source and target languages.</p> <p>Returns:</p> Type Description <code>Any</code> <p>Translation object configured for source to target language.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If either the source or target language is not installed.</p>"},{"location":"api/#es_translator.interpreters.Argos.download_and_install_package","title":"download_and_install_package","text":"<pre><code>download_and_install_package(package)\n</code></pre> <p>Download and install a language package.</p> <p>Uses file locking to prevent concurrent downloads of the same package. Skips installation if the package is already installed.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>Any</code> <p>The package to download and install.</p> required <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>Installation result or None if package was already installed.</p> <p>Raises:</p> Type Description <code>ArgosPackageDownloadLockTimeout</code> <p>If lock cannot be acquired within timeout.</p> Source code in <code>es_translator/interpreters/argos/argos.py</code> <pre><code>def download_and_install_package(self, package: Any) -&gt; Optional[Any]:\n    \"\"\"Download and install a language package.\n\n    Uses file locking to prevent concurrent downloads of the same package.\n    Skips installation if the package is already installed.\n\n    Args:\n        package: The package to download and install.\n\n    Returns:\n        Installation result or None if package was already installed.\n\n    Raises:\n        ArgosPackageDownloadLockTimeout: If lock cannot be acquired within timeout.\n    \"\"\"\n    try:\n        temp_dir = Path(tempfile.gettempdir())\n        lock_path = temp_dir / f'{package.from_code}_{package.to_code}.lock'\n\n        with FileLock(lock_path, timeout=600).acquire(timeout=600):\n            if self.is_package_installed(package):\n                return None\n            download_path = package.download()\n            logger.info(f'Installing Argos package {package}')\n            return argospackage.install_from_path(download_path)\n    except Timeout as exc:\n        raise ArgosPackageDownloadLockTimeout(\n            f'Another instance of the program is downloading the package {package}. Please try again later.') from exc\n</code></pre>"},{"location":"api/#es_translator.interpreters.Argos.download_necessary_languages","title":"download_necessary_languages","text":"<pre><code>download_necessary_languages()\n</code></pre> <p>Download necessary language packages if not installed.</p> <p>Steps: 1. Updates the package index. 2. Finds the necessary package. 3. Downloads and installs the package.</p> <p>Raises:</p> Type Description <code>ArgosPairNotAvailable</code> <p>If the necessary language package could not be found.</p> <code>ArgosPackageDownloadLockTimeout</code> <p>If lock cannot be acquired within timeout.</p> Source code in <code>es_translator/interpreters/argos/argos.py</code> <pre><code>def download_necessary_languages(self) -&gt; None:\n    \"\"\"Download necessary language packages if not installed.\n\n    Steps:\n    1. Updates the package index.\n    2. Finds the necessary package.\n    3. Downloads and installs the package.\n\n    Raises:\n        ArgosPairNotAvailable: If the necessary language package could not be found.\n        ArgosPackageDownloadLockTimeout: If lock cannot be acquired within timeout.\n    \"\"\"\n    self.update_package_index()\n    necessary_package = self.find_necessary_package()\n    self.download_and_install_package(necessary_package)\n</code></pre>"},{"location":"api/#es_translator.interpreters.Argos.find_necessary_package","title":"find_necessary_package","text":"<pre><code>find_necessary_package()\n</code></pre> <p>Find the necessary language package.</p> <p>Searches available packages for one matching the source and target languages.</p> <p>Returns:</p> Type Description <code>Any</code> <p>The necessary language package object.</p> <p>Raises:</p> Type Description <code>ArgosPairNotAvailable</code> <p>If the necessary language package could not be found.</p> Source code in <code>es_translator/interpreters/argos/argos.py</code> <pre><code>def find_necessary_package(self) -&gt; Any:\n    \"\"\"Find the necessary language package.\n\n    Searches available packages for one matching the source and target languages.\n\n    Returns:\n        The necessary language package object.\n\n    Raises:\n        ArgosPairNotAvailable: If the necessary language package could not be found.\n    \"\"\"\n    for package in argospackage.get_available_packages():\n        if package.from_code == self.source_alpha_2 and package.to_code == self.target_alpha_2:\n            return package\n    raise ArgosPairNotAvailable\n</code></pre>"},{"location":"api/#es_translator.interpreters.Argos.is_package_installed","title":"is_package_installed","text":"<pre><code>is_package_installed(package)\n</code></pre> <p>Check if a package is installed.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>Any</code> <p>The package to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the package is installed, False otherwise.</p> Source code in <code>es_translator/interpreters/argos/argos.py</code> <pre><code>def is_package_installed(self, package: Any) -&gt; bool:\n    \"\"\"Check if a package is installed.\n\n    Args:\n        package: The package to check.\n\n    Returns:\n        True if the package is installed, False otherwise.\n    \"\"\"\n    return package in argospackage.get_installed_packages()\n</code></pre>"},{"location":"api/#es_translator.interpreters.Argos.translate","title":"translate","text":"<pre><code>translate(text_input)\n</code></pre> <p>Translate input text from source language to target language.</p> <p>Parameters:</p> Name Type Description Default <code>text_input</code> <code>str</code> <p>The input text in the source language.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The translated text in the target language.</p> Source code in <code>es_translator/interpreters/argos/argos.py</code> <pre><code>def translate(self, text_input: str) -&gt; str:\n    \"\"\"Translate input text from source language to target language.\n\n    Args:\n        text_input: The input text in the source language.\n\n    Returns:\n        The translated text in the target language.\n    \"\"\"\n    return self.translation.translate(text_input)\n</code></pre>"},{"location":"api/#es_translator.interpreters.Argos.update_package_index","title":"update_package_index","text":"<pre><code>update_package_index()\n</code></pre> <p>Update the Argos package index to fetch latest available packages.</p> Source code in <code>es_translator/interpreters/argos/argos.py</code> <pre><code>def update_package_index(self) -&gt; None:\n    \"\"\"Update the Argos package index to fetch latest available packages.\"\"\"\n    argospackage.update_package_index()\n</code></pre>"},{"location":"api/#apertium","title":"Apertium","text":"<p>Apertium is a rule-based machine translation platform that supports a wide variety of language pairs, especially for related languages.</p>"},{"location":"api/#es_translator.interpreters.Apertium","title":"es_translator.interpreters.Apertium","text":"<pre><code>Apertium(\n    source=None,\n    target=None,\n    intermediary=None,\n    pack_dir=None,\n)\n</code></pre> <p>               Bases: <code>AbstractInterpreter</code></p> <p>Apertium translation interpreter.</p> <p>Provides translation capabilities using the Apertium translation engine, with support for direct translation and intermediary language pairs.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>Identifier for this interpreter ('APERTIUM').</p> <code>repository</code> <p>ApertiumRepository instance for package management.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Optional[str]</code> <p>Source language code.</p> <code>None</code> <code>target</code> <code>Optional[str]</code> <p>Target language code.</p> <code>None</code> <code>intermediary</code> <code>Optional[str]</code> <p>Optional intermediary language for indirect translation.</p> <code>None</code> <code>pack_dir</code> <code>Optional[str]</code> <p>Directory for storing translation packages.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If the language pair is not available in the repository.</p> Source code in <code>es_translator/interpreters/apertium/apertium.py</code> <pre><code>def __init__(\n        self,\n        source: Optional[str] = None,\n        target: Optional[str] = None,\n        intermediary: Optional[str] = None,\n        pack_dir: Optional[str] = None) -&gt; None:\n    \"\"\"Initialize the Apertium interpreter.\n\n    Args:\n        source: Source language code.\n        target: Target language code.\n        intermediary: Optional intermediary language for indirect translation.\n        pack_dir: Directory for storing translation packages.\n\n    Raises:\n        Exception: If the language pair is not available in the repository.\n    \"\"\"\n    super().__init__(source, target, intermediary, pack_dir)\n    # A class to download necessary pair package\n    self.repository = ApertiumRepository(self.pack_dir)\n    # Raise an exception if the language pair is unknown\n    if not self.is_pair_available and self.has_pair:\n        try:\n            self.download_necessary_pairs()\n        except StopIteration:\n            raise Exception('The pair is not available')\n    else:\n        logger.info(f'Existing package(s) found for pair {self.pair}')\n</code></pre>"},{"location":"api/#es_translator.interpreters.Apertium.any_pair_variant_in_packages","title":"any_pair_variant_in_packages  <code>property</code>","text":"<pre><code>any_pair_variant_in_packages\n</code></pre> <p>Check if any variant of the current pair exists in packages.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the pair is available in remote repository.</p>"},{"location":"api/#es_translator.interpreters.Apertium.intermediary_pairs","title":"intermediary_pairs  <code>property</code>","text":"<pre><code>intermediary_pairs\n</code></pre> <p>Get intermediary language pairs for indirect translation.</p> <p>Automatically finds an intermediary language if not specified by building a language tree and finding a path from source to target.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of two language pair strings for indirect translation.</p>"},{"location":"api/#es_translator.interpreters.Apertium.intermediary_source_pair","title":"intermediary_source_pair  <code>property</code>","text":"<pre><code>intermediary_source_pair\n</code></pre> <p>Get source-to-intermediary language pair.</p> <p>Returns:</p> Type Description <code>str</code> <p>Language pair string (e.g., 'eng-spa').</p>"},{"location":"api/#es_translator.interpreters.Apertium.intermediary_source_pair_package","title":"intermediary_source_pair_package  <code>property</code>","text":"<pre><code>intermediary_source_pair_package\n</code></pre> <p>Get package name for source-to-intermediary pair.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Package name string or None if not found.</p>"},{"location":"api/#es_translator.interpreters.Apertium.intermediary_target_pair","title":"intermediary_target_pair  <code>property</code>","text":"<pre><code>intermediary_target_pair\n</code></pre> <p>Get intermediary-to-target language pair.</p> <p>Returns:</p> Type Description <code>str</code> <p>Language pair string (e.g., 'spa-fra').</p>"},{"location":"api/#es_translator.interpreters.Apertium.intermediary_target_pair_package","title":"intermediary_target_pair_package  <code>property</code>","text":"<pre><code>intermediary_target_pair_package\n</code></pre> <p>Get package name for intermediary-to-target pair.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Package name string or None if not found.</p>"},{"location":"api/#es_translator.interpreters.Apertium.is_pair_available","title":"is_pair_available  <code>property</code>","text":"<pre><code>is_pair_available\n</code></pre> <p>Check if the language pair is available locally.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if pair is available without intermediary.</p>"},{"location":"api/#es_translator.interpreters.Apertium.local_pairs","title":"local_pairs  <code>property</code>","text":"<pre><code>local_pairs\n</code></pre> <p>Get locally installed language pairs.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of locally available language pair codes.</p>"},{"location":"api/#es_translator.interpreters.Apertium.pair_package","title":"pair_package  <code>property</code>","text":"<pre><code>pair_package\n</code></pre> <p>Get the package name for the current language pair.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Package name string or None if not found.</p>"},{"location":"api/#es_translator.interpreters.Apertium.pairs_pipeline","title":"pairs_pipeline  <code>property</code>","text":"<pre><code>pairs_pipeline\n</code></pre> <p>Get the translation pipeline (direct or via intermediary).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of language pair codes to process sequentially.</p>"},{"location":"api/#es_translator.interpreters.Apertium.remote_pairs","title":"remote_pairs  <code>cached</code> <code>property</code>","text":"<pre><code>remote_pairs\n</code></pre> <p>Get remotely available language pairs from repository.</p> <p>Parameters:</p> Name Type Description Default <code>module</code> <p>Repository module to query (default: 'trunk').</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List of available language pair codes from the repository.</p>"},{"location":"api/#es_translator.interpreters.Apertium.download_intermediary_pairs","title":"download_intermediary_pairs","text":"<pre><code>download_intermediary_pairs()\n</code></pre> <p>Download both intermediary language pairs for indirect translation.</p> Source code in <code>es_translator/interpreters/apertium/apertium.py</code> <pre><code>def download_intermediary_pairs(self) -&gt; None:\n    \"\"\"Download both intermediary language pairs for indirect translation.\"\"\"\n    for pair in self.intermediary_pairs:\n        self.download_pair(pair)\n</code></pre>"},{"location":"api/#es_translator.interpreters.Apertium.download_necessary_pairs","title":"download_necessary_pairs","text":"<pre><code>download_necessary_pairs()\n</code></pre> <p>Download required language pair packages.</p> <p>Downloads either a direct pair or intermediary pairs depending on availability in the repository.</p> Source code in <code>es_translator/interpreters/apertium/apertium.py</code> <pre><code>def download_necessary_pairs(self) -&gt; None:\n    \"\"\"Download required language pair packages.\n\n    Downloads either a direct pair or intermediary pairs depending on\n    availability in the repository.\n    \"\"\"\n    logger.info(f'Downloading necessary package(s) for {self.pair}')\n    if self.any_pair_variant_in_packages:\n        self.download_pair()\n    else:\n        self.download_intermediary_pairs()\n</code></pre>"},{"location":"api/#es_translator.interpreters.Apertium.download_pair","title":"download_pair","text":"<pre><code>download_pair(pair=None)\n</code></pre> <p>Download and install a specific language pair package.</p> <p>Parameters:</p> Name Type Description Default <code>pair</code> <code>Optional[str]</code> <p>Language pair to download. If None, uses current pair.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Path to the installed package directory.</p> Source code in <code>es_translator/interpreters/apertium/apertium.py</code> <pre><code>def download_pair(self, pair: Optional[str] = None) -&gt; str:\n    \"\"\"Download and install a specific language pair package.\n\n    Args:\n        pair: Language pair to download. If None, uses current pair.\n\n    Returns:\n        Path to the installed package directory.\n    \"\"\"\n    pair = self.pair_alpha_3 if pair is None else to_alpha_3_pair(pair)\n    # All commands must be run from the pack dir\n    return self.repository.install_pair_package(pair)\n</code></pre>"},{"location":"api/#es_translator.interpreters.Apertium.first_pairs_path","title":"first_pairs_path","text":"<pre><code>first_pairs_path(leaf, lang)\n</code></pre> <p>Find the first path from a tree leaf to a target language.</p> <p>Parameters:</p> Name Type Description Default <code>leaf</code> <code>dict</code> <p>Tree node dictionary with 'lang' and 'children' keys.</p> required <code>lang</code> <code>str</code> <p>Target language to find path to.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List of language codes forming the path.</p> Source code in <code>es_translator/interpreters/apertium/apertium.py</code> <pre><code>def first_pairs_path(self, leaf: dict, lang: str) -&gt; list[str]:\n    \"\"\"Find the first path from a tree leaf to a target language.\n\n    Args:\n        leaf: Tree node dictionary with 'lang' and 'children' keys.\n        lang: Target language to find path to.\n\n    Returns:\n        List of language codes forming the path.\n    \"\"\"\n    path = []\n    for child_leaf in leaf['children'].values():\n        if self.leaf_has_lang(child_leaf, lang):\n            path.append(child_leaf['lang'])\n            path = path + self.first_pairs_path(child_leaf, lang)\n            break\n    return path\n</code></pre>"},{"location":"api/#es_translator.interpreters.Apertium.lang_tree","title":"lang_tree","text":"<pre><code>lang_tree(lang, pairs, depth=2)\n</code></pre> <p>Build a tree of language connections from available pairs.</p> <p>Parameters:</p> Name Type Description Default <code>lang</code> <code>str</code> <p>Root language for the tree.</p> required <code>pairs</code> <code>list[list[str]]</code> <p>List of language pair lists.</p> required <code>depth</code> <code>int</code> <p>Maximum depth to traverse (default: 2).</p> <code>2</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary tree structure with 'lang' and 'children' keys.</p> Source code in <code>es_translator/interpreters/apertium/apertium.py</code> <pre><code>def lang_tree(self, lang: str, pairs: list[list[str]], depth: int = 2) -&gt; dict:\n    \"\"\"Build a tree of language connections from available pairs.\n\n    Args:\n        lang: Root language for the tree.\n        pairs: List of language pair lists.\n        depth: Maximum depth to traverse (default: 2).\n\n    Returns:\n        Dictionary tree structure with 'lang' and 'children' keys.\n    \"\"\"\n    tree = {'lang': lang, 'children': {}}\n    for pair in pairs:\n        if lang in pair and depth &gt; 0:\n            child_lang = next(item for item in pair if item != lang)\n            tree[\"children\"][child_lang] = self.lang_tree(\n                child_lang, pairs, depth - 1)\n    return tree\n</code></pre>"},{"location":"api/#es_translator.interpreters.Apertium.leaf_has_lang","title":"leaf_has_lang","text":"<pre><code>leaf_has_lang(leaf, lang)\n</code></pre> <p>Check if a tree leaf contains or leads to a target language.</p> <p>Parameters:</p> Name Type Description Default <code>leaf</code> <code>dict</code> <p>Tree node dictionary with 'lang' and 'children' keys.</p> required <code>lang</code> <code>str</code> <p>Target language to search for.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the language is found in the leaf or its descendants.</p> Source code in <code>es_translator/interpreters/apertium/apertium.py</code> <pre><code>def leaf_has_lang(self, leaf: dict, lang: str) -&gt; bool:\n    \"\"\"Check if a tree leaf contains or leads to a target language.\n\n    Args:\n        leaf: Tree node dictionary with 'lang' and 'children' keys.\n        lang: Target language to search for.\n\n    Returns:\n        True if the language is found in the leaf or its descendants.\n    \"\"\"\n    children = leaf['children'].values()\n    return lang in leaf['children'] or any(\n        self.leaf_has_lang(\n            child_leaf,\n            lang) for child_leaf in children)\n</code></pre>"},{"location":"api/#es_translator.interpreters.Apertium.pair_to_pair_package","title":"pair_to_pair_package","text":"<pre><code>pair_to_pair_package(pair)\n</code></pre> <p>Convert language pair to package name.</p> <p>Checks both the pair and its reverse for availability in remote packages.</p> <p>Parameters:</p> Name Type Description Default <code>pair</code> <code>str</code> <p>Language pair string (e.g., 'en-es').</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Package name if found, None otherwise.</p> Source code in <code>es_translator/interpreters/apertium/apertium.py</code> <pre><code>def pair_to_pair_package(self, pair: str) -&gt; Optional[str]:\n    \"\"\"Convert language pair to package name.\n\n    Checks both the pair and its reverse for availability in remote packages.\n\n    Args:\n        pair: Language pair string (e.g., 'en-es').\n\n    Returns:\n        Package name if found, None otherwise.\n    \"\"\"\n    pair_inversed = '-'.join(pair.split('-')[::-1])\n    combinations = [to_alpha_3_pair(pair), to_alpha_3_pair(pair_inversed)]\n    try:\n        return next(p for p in self.remote_pairs if p in combinations)\n    except StopIteration:\n        return None\n</code></pre>"},{"location":"api/#es_translator.interpreters.Apertium.translate","title":"translate","text":"<pre><code>translate(input)\n</code></pre> <p>Translate text through the translation pipeline.</p> <p>If using an intermediary language, translates through multiple pairs.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>str</code> <p>Text to translate.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Translated text string.</p> Source code in <code>es_translator/interpreters/apertium/apertium.py</code> <pre><code>def translate(self, input: str) -&gt; str:\n    \"\"\"Translate text through the translation pipeline.\n\n    If using an intermediary language, translates through multiple pairs.\n\n    Args:\n        input: Text to translate.\n\n    Returns:\n        Translated text string.\n    \"\"\"\n    for pair in self.pairs_pipeline:\n        # Create a sub-process which can receive an input\n        input = self.translate_with_apertium(input, pair)\n    return input\n</code></pre>"},{"location":"api/#es_translator.interpreters.Apertium.translate_with_apertium","title":"translate_with_apertium","text":"<pre><code>translate_with_apertium(input, pair)\n</code></pre> <p>Translate text using Apertium for a specific language pair.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>str</code> <p>Text to translate.</p> required <code>pair</code> <code>str</code> <p>Language pair code (e.g., 'eng-spa').</p> required <p>Returns:</p> Type Description <code>str</code> <p>Translated text string.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If translation fails.</p> Source code in <code>es_translator/interpreters/apertium/apertium.py</code> <pre><code>def translate_with_apertium(self, input: str, pair: str) -&gt; str:\n    \"\"\"Translate text using Apertium for a specific language pair.\n\n    Args:\n        input: Text to translate.\n        pair: Language pair code (e.g., 'eng-spa').\n\n    Returns:\n        Translated text string.\n\n    Raises:\n        Exception: If translation fails.\n    \"\"\"\n    try:\n        # Works with a temporary file as buffer (opened in text mode)\n        with NamedTemporaryFile(mode='w+t') as temp_input_file:\n            temp_input_file.writelines(input)\n            temp_input_file.seek(0)\n            input_translated = apertium(\n                '-ud', self.pack_dir, pair, temp_input_file.name)\n    except ErrorReturnCode:\n        raise Exception('Unable to translate this string.')\n    return str(input_translated)\n</code></pre>"},{"location":"api/#repository-management","title":"Repository Management","text":""},{"location":"api/#es_translator.interpreters.apertium.repository.ApertiumRepository","title":"es_translator.interpreters.apertium.repository.ApertiumRepository","text":"<pre><code>ApertiumRepository(cache_dir=None, arch=None)\n</code></pre> <p>Manages Apertium package repository operations.</p> <p>Handles downloading, extracting, and installing Apertium translation pairs from the official repository.</p> <p>Attributes:</p> Name Type Description <code>cache_dir</code> <p>Directory path for caching downloaded packages.</p> <code>arch</code> <p>System architecture ('amd64', 'i386', etc.).</p> <p>Parameters:</p> Name Type Description Default <code>cache_dir</code> <code>Optional[str]</code> <p>Directory for caching downloaded packages. Defaults to None.</p> <code>None</code> <code>arch</code> <code>Optional[str]</code> <p>Architecture string ('amd64', 'i386'). If None, auto-detect.</p> <code>None</code> Source code in <code>es_translator/interpreters/apertium/repository.py</code> <pre><code>def __init__(self, cache_dir: Optional[str] = None, arch: Optional[str] = None):\n    \"\"\"Initialize the Apertium repository handler.\n\n    Args:\n        cache_dir: Directory for caching downloaded packages. Defaults to None.\n        arch: Architecture string ('amd64', 'i386'). If None, auto-detect.\n    \"\"\"\n    self.cache_dir = abspath(cache_dir) if cache_dir else abspath('.')\n    self.arch = arch\n</code></pre>"},{"location":"api/#es_translator.interpreters.apertium.repository.ApertiumRepository.control_file_content","title":"control_file_content  <code>cached</code> <code>property</code>","text":"<pre><code>control_file_content\n</code></pre> <p>Fetch and cache the Packages control file content.</p> <p>Returns:</p> Type Description <code>str</code> <p>Decoded UTF-8 content of the Packages file.</p> <p>Raises:</p> Type Description <code>URLError</code> <p>If the URL cannot be accessed.</p> <code>HTTPError</code> <p>If HTTP request fails.</p>"},{"location":"api/#es_translator.interpreters.apertium.repository.ApertiumRepository.packages","title":"packages  <code>cached</code> <code>property</code>","text":"<pre><code>packages\n</code></pre> <p>Parse and cache the list of available packages.</p> <p>Returns:</p> Type Description <code>list[dict]</code> <p>List of package metadata dictionaries.</p>"},{"location":"api/#es_translator.interpreters.apertium.repository.ApertiumRepository.packages_file_url","title":"packages_file_url  <code>property</code>","text":"<pre><code>packages_file_url\n</code></pre> <p>Get the Packages file URL for the configured architecture.</p>"},{"location":"api/#es_translator.interpreters.apertium.repository.ApertiumRepository.pair_packages","title":"pair_packages  <code>cached</code> <code>property</code>","text":"<pre><code>pair_packages\n</code></pre> <p>Get filtered list of Apertium translation pair packages.</p> <p>Returns:</p> Type Description <code>list[dict]</code> <p>List of package dictionaries that are translation pairs.</p>"},{"location":"api/#es_translator.interpreters.apertium.repository.ApertiumRepository.clear_modes","title":"clear_modes","text":"<pre><code>clear_modes()\n</code></pre> <p>Remove all mode files from the cache directory.</p> Source code in <code>es_translator/interpreters/apertium/repository.py</code> <pre><code>def clear_modes(self) -&gt; None:\n    \"\"\"Remove all mode files from the cache directory.\"\"\"\n    with pushd(self.cache_dir):\n        rm('-Rf', 'modes')\n</code></pre>"},{"location":"api/#es_translator.interpreters.apertium.repository.ApertiumRepository.create_pair_package_alias","title":"create_pair_package_alias","text":"<pre><code>create_pair_package_alias(package_dir)\n</code></pre> <p>Create symbolic links for alternative language code formats.</p> <p>Creates aliases between ISO 639-1 (2-letter) and ISO 639-3 (3-letter) codes.</p> <p>Parameters:</p> Name Type Description Default <code>package_dir</code> <code>str</code> <p>Directory containing the extracted package.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Path to the created alias directory.</p> Source code in <code>es_translator/interpreters/apertium/repository.py</code> <pre><code>def create_pair_package_alias(self, package_dir: str) -&gt; str:\n    \"\"\"Create symbolic links for alternative language code formats.\n\n    Creates aliases between ISO 639-1 (2-letter) and ISO 639-3 (3-letter) codes.\n\n    Args:\n        package_dir: Directory containing the extracted package.\n\n    Returns:\n        Path to the created alias directory.\n    \"\"\"\n    extraction_dir = dirname(package_dir) + '/'\n    source, target = basename(package_dir).split('apertium-')[-1].split('-')\n\n    # Determine alias codes based on current format\n    if len(source) == 2:\n        aliases = (to_alpha_3(source), to_alpha_3(target))\n    else:\n        aliases = (to_alpha_2(source), to_alpha_2(target))\n\n    # Build the alias dir using the alias codes\n    alias_dir = join(extraction_dir, f'apertium-{aliases[0]}-{aliases[1]}')\n    mode_file = join(extraction_dir, 'modes', f'{source}-{target}.mode')\n    mode_alias_file = join(extraction_dir, 'modes', f'{aliases[0]}-{aliases[1]}.mode')\n\n    # Use symbolic links for aliases\n    create_symlink(package_dir, alias_dir)\n    create_symlink(mode_file, mode_alias_file)\n\n    return alias_dir\n</code></pre>"},{"location":"api/#es_translator.interpreters.apertium.repository.ApertiumRepository.download_package","title":"download_package","text":"<pre><code>download_package(name, force=False)\n</code></pre> <p>Download a package from the repository.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Package name to download.</p> required <code>force</code> <code>bool</code> <p>If True, re-download even if package already exists.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Path to the downloaded .deb file.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If package cannot be found or downloaded.</p> Source code in <code>es_translator/interpreters/apertium/repository.py</code> <pre><code>def download_package(self, name: str, force: bool = False) -&gt; str:\n    \"\"\"Download a package from the repository.\n\n    Args:\n        name: Package name to download.\n        force: If True, re-download even if package already exists.\n\n    Returns:\n        Path to the downloaded .deb file.\n\n    Raises:\n        Exception: If package cannot be found or downloaded.\n    \"\"\"\n    package = self.find_package(name)\n    if package is None:\n        raise Exception(f'Package {name} not found in repository')\n\n    package_dir = join(self.cache_dir, name)\n    package_file = join(package_dir, 'package.deb')\n    mkdir('-p', package_dir)\n\n    # Don't download the file twice\n    if force or not isfile(package_file):\n        logger.info(f'Downloading package {name}')\n\n        # Try the URL from Packages file first\n        package_url = f\"{REPOSITORY_URL}/{package['Filename']}\"\n        try:\n            request.urlretrieve(package_url, package_file)\n        except Exception as e:\n            # If that fails, try to find the latest version in the pool directory\n            logger.warning(f'Failed to download from Packages file URL: {e}')\n            package_url = self.find_latest_package_in_pool(name, package['Filename'])\n            request.urlretrieve(package_url, package_file)\n\n    return package_file\n</code></pre>"},{"location":"api/#es_translator.interpreters.apertium.repository.ApertiumRepository.download_pair_package","title":"download_pair_package","text":"<pre><code>download_pair_package(pair)\n</code></pre> <p>Download a translation pair package.</p> <p>Parameters:</p> Name Type Description Default <code>pair</code> <code>str</code> <p>Language pair in format 'source-target'.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Path to the downloaded .deb file.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If no pair package is available for the given languages.</p> Source code in <code>es_translator/interpreters/apertium/repository.py</code> <pre><code>def download_pair_package(self, pair: str) -&gt; str:\n    \"\"\"Download a translation pair package.\n\n    Args:\n        pair: Language pair in format 'source-target'.\n\n    Returns:\n        Path to the downloaded .deb file.\n\n    Raises:\n        Exception: If no pair package is available for the given languages.\n    \"\"\"\n    pair_package = self.find_pair_package(pair)\n    if pair_package is not None:\n        return self.download_package(pair_package.get('Package'))\n    else:\n        raise Exception(f'No pair package available for \"{pair}\"')\n</code></pre>"},{"location":"api/#es_translator.interpreters.apertium.repository.ApertiumRepository.extract_pair_package","title":"extract_pair_package","text":"<pre><code>extract_pair_package(file, extraction_dir='.')\n</code></pre> <p>Extract a translation pair .deb package.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>Path to the .deb file to extract.</p> required <code>extraction_dir</code> <code>str</code> <p>Directory to extract files into. Defaults to '.'.</p> <code>'.'</code> <p>Returns:</p> Type Description <code>str</code> <p>Path to the working directory containing extracted files.</p> Source code in <code>es_translator/interpreters/apertium/repository.py</code> <pre><code>def extract_pair_package(self, file: str, extraction_dir: str = '.') -&gt; str:\n    \"\"\"Extract a translation pair .deb package.\n\n    Args:\n        file: Path to the .deb file to extract.\n        extraction_dir: Directory to extract files into. Defaults to '.'.\n\n    Returns:\n        Path to the working directory containing extracted files.\n    \"\"\"\n    workdir = dirname(file)\n    with pushd(workdir):\n        # Extract the file from the .deb\n        dpkg_deb('-x', file, extraction_dir)\n        # Copy the files we need\n        cp('-rlf', glob('usr/share/apertium/*'), extraction_dir)\n        # Remove everything else\n        rm('-Rf', 'usr')\n        # Rewrite paths in modes files to point to the working directory\n        for mode in glob('modes/*.mode'):\n            self.replace_in_file(mode, '/usr/share/apertium', workdir)\n    return workdir\n</code></pre>"},{"location":"api/#es_translator.interpreters.apertium.repository.ApertiumRepository.find_latest_package_in_pool","title":"find_latest_package_in_pool","text":"<pre><code>find_latest_package_in_pool(package_name, filename)\n</code></pre> <p>Find latest package version from pool directory.</p> <p>Used as fallback when the Packages file lists an outdated version.</p> <p>Parameters:</p> Name Type Description Default <code>package_name</code> <code>str</code> <p>Name of the package to find.</p> required <code>filename</code> <code>str</code> <p>Original filename from Packages file (used to determine pool directory).</p> required <p>Returns:</p> Type Description <code>str</code> <p>URL of the latest package version found.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If no matching package is found in the pool directory.</p> <code>URLError</code> <p>If the pool directory cannot be accessed.</p> Source code in <code>es_translator/interpreters/apertium/repository.py</code> <pre><code>def find_latest_package_in_pool(self, package_name: str, filename: str) -&gt; str:\n    \"\"\"Find latest package version from pool directory.\n\n    Used as fallback when the Packages file lists an outdated version.\n\n    Args:\n        package_name: Name of the package to find.\n        filename: Original filename from Packages file (used to determine pool directory).\n\n    Returns:\n        URL of the latest package version found.\n\n    Raises:\n        Exception: If no matching package is found in the pool directory.\n        URLError: If the pool directory cannot be accessed.\n    \"\"\"\n    logger.info('Attempting to find latest version from pool directory')\n\n    # Extract the pool directory path\n    filename_parts = filename.split('/')\n    pool_dir_url = f\"{REPOSITORY_URL}/{'/'.join(filename_parts[:-1])}/\"\n\n    try:\n        # Fetch the directory listing\n        response = request.urlopen(pool_dir_url)\n        html_content = response.read().decode('utf-8')\n    except (URLError, HTTPError) as e:\n        logger.error(f'Failed to access pool directory {pool_dir_url}: {e}')\n        raise\n\n    # Find all .deb files for this package\n    pattern = rf'href=\"({re.escape(package_name)}_[^\"]+\\.deb)\"'\n    matches = re.findall(pattern, html_content)\n\n    if matches:\n        # Use the last one (likely the newest based on alphabetical sorting)\n        latest_file = matches[-1]\n        package_url = pool_dir_url + latest_file\n        logger.info(f'Found latest version: {latest_file}')\n        return package_url\n    else:\n        raise Exception(f'Could not find package {package_name} in pool directory')\n</code></pre>"},{"location":"api/#es_translator.interpreters.apertium.repository.ApertiumRepository.find_package","title":"find_package","text":"<pre><code>find_package(package)\n</code></pre> <p>Find a package by name or provided name.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>Package name to search for.</p> required <p>Returns:</p> Type Description <code>Optional[dict]</code> <p>Package metadata dictionary if found, None otherwise.</p> Source code in <code>es_translator/interpreters/apertium/repository.py</code> <pre><code>def find_package(self, package: str) -&gt; Optional[dict]:\n    \"\"\"Find a package by name or provided name.\n\n    Args:\n        package: Package name to search for.\n\n    Returns:\n        Package metadata dictionary if found, None otherwise.\n    \"\"\"\n    def is_package(c: dict) -&gt; bool:\n        return c.get('Package') == package or c.get('Provides') == package\n\n    try:\n        return next(filter(is_package, self.packages))\n    except StopIteration:\n        logger.warning(f'Unable to find package {package}')\n        return None\n</code></pre>"},{"location":"api/#es_translator.interpreters.apertium.repository.ApertiumRepository.find_pair_package","title":"find_pair_package","text":"<pre><code>find_pair_package(pair)\n</code></pre> <p>Find a translation pair package.</p> <p>Searches for both forward (source-target) and reverse (target-source) pairs.</p> <p>Parameters:</p> Name Type Description Default <code>pair</code> <code>str</code> <p>Language pair in format 'source-target'.</p> required <p>Returns:</p> Type Description <code>Optional[dict]</code> <p>Package metadata dictionary if found, None otherwise.</p> Source code in <code>es_translator/interpreters/apertium/repository.py</code> <pre><code>def find_pair_package(self, pair: str) -&gt; Optional[dict]:\n    \"\"\"Find a translation pair package.\n\n    Searches for both forward (source-target) and reverse (target-source) pairs.\n\n    Args:\n        pair: Language pair in format 'source-target'.\n\n    Returns:\n        Package metadata dictionary if found, None otherwise.\n    \"\"\"\n    pair = to_alpha_3_pair(pair)\n    pair_inversed = '-'.join(pair.split('-')[::-1])\n\n    def is_pair(c: dict) -&gt; bool:\n        package_name = c.get('Package', '')\n        return package_name.endswith(pair) or package_name.endswith(pair_inversed)\n\n    try:\n        return next(filter(is_pair, self.pair_packages))\n    except StopIteration:\n        return None\n</code></pre>"},{"location":"api/#es_translator.interpreters.apertium.repository.ApertiumRepository.import_modes","title":"import_modes","text":"<pre><code>import_modes(clear=True)\n</code></pre> <p>Import all mode files from installed packages into the modes directory.</p> <p>Parameters:</p> Name Type Description Default <code>clear</code> <code>bool</code> <p>If True, clear existing modes before importing. Defaults to True.</p> <code>True</code> Source code in <code>es_translator/interpreters/apertium/repository.py</code> <pre><code>def import_modes(self, clear: bool = True) -&gt; None:\n    \"\"\"Import all mode files from installed packages into the modes directory.\n\n    Args:\n        clear: If True, clear existing modes before importing. Defaults to True.\n    \"\"\"\n    with pushd(self.cache_dir):\n        if clear:\n            self.clear_modes()\n        mkdir('-p', 'modes')\n        # Copy all the mode files from installed packages\n        mode_files = glob('./*/modes/*.mode')\n        if mode_files:\n            cp(mode_files, './modes')\n</code></pre>"},{"location":"api/#es_translator.interpreters.apertium.repository.ApertiumRepository.install_pair_package","title":"install_pair_package","text":"<pre><code>install_pair_package(pair)\n</code></pre> <p>Download, extract, and install a translation pair package.</p> <p>Parameters:</p> Name Type Description Default <code>pair</code> <code>str</code> <p>Language pair in format 'source-target'.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Path to the installed package directory.</p> Source code in <code>es_translator/interpreters/apertium/repository.py</code> <pre><code>def install_pair_package(self, pair: str) -&gt; str:\n    \"\"\"Download, extract, and install a translation pair package.\n\n    Args:\n        pair: Language pair in format 'source-target'.\n\n    Returns:\n        Path to the installed package directory.\n    \"\"\"\n    logger.info(f'Installing pair package {pair}')\n    package_file = self.download_pair_package(pair)\n    package_dir = self.extract_pair_package(package_file)\n    self.create_pair_package_alias(package_dir)\n    self.import_modes(clear=False)\n    return package_dir\n</code></pre>"},{"location":"api/#es_translator.interpreters.apertium.repository.ApertiumRepository.is_apertium_pair","title":"is_apertium_pair","text":"<pre><code>is_apertium_pair(control)\n</code></pre> <p>Check if a package is an Apertium translation pair.</p> <p>Parameters:</p> Name Type Description Default <code>control</code> <code>dict</code> <p>Package metadata dictionary.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if package is a translation pair (format: apertium-XX-YY).</p> Source code in <code>es_translator/interpreters/apertium/repository.py</code> <pre><code>def is_apertium_pair(self, control: dict) -&gt; bool:\n    \"\"\"Check if a package is an Apertium translation pair.\n\n    Args:\n        control: Package metadata dictionary.\n\n    Returns:\n        True if package is a translation pair (format: apertium-XX-YY).\n    \"\"\"\n    try:\n        parts = control['Package'].split('-')\n        return len(parts) == 3 and parts[0] == 'apertium'\n    except KeyError:\n        return False\n</code></pre>"},{"location":"api/#es_translator.interpreters.apertium.repository.ApertiumRepository.replace_in_file","title":"replace_in_file","text":"<pre><code>replace_in_file(file, target, replacement)\n</code></pre> <p>Replace all occurrences of target string in a file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>Path to the file to modify.</p> required <code>target</code> <code>str</code> <p>String to search for.</p> required <code>replacement</code> <code>str</code> <p>String to replace with.</p> required Source code in <code>es_translator/interpreters/apertium/repository.py</code> <pre><code>def replace_in_file(self, file: str, target: str, replacement: str) -&gt; None:\n    \"\"\"Replace all occurrences of target string in a file.\n\n    Args:\n        file: Path to the file to modify.\n        target: String to search for.\n        replacement: String to replace with.\n    \"\"\"\n    with FileInput(file, inplace=True) as fileinput:\n        for line in fileinput:\n            print(line.replace(target, replacement), end='')\n</code></pre>"},{"location":"contributing/","title":"Contributing to EsTranslator","text":"<p>Thank you for your interest in contributing to the EsTranslator project! We welcome contributions from the community to help improve and grow the library. This document provides guidelines and information on how you can contribute effectively.</p>"},{"location":"contributing/#ways-to-contribute","title":"Ways to Contribute","text":"<p>There are several ways you can contribute to the EsTranslator project:</p> <ol> <li> <p>Report Issues: If you encounter any bugs, issues, or have feature requests, please submit an issue on our GitHub repository. Include as much detail as possible to help us understand and address the problem.</p> </li> <li> <p>Provide Feedback: If you have feedback or suggestions for improving EsTranslator, we would love to hear from you. You can share your thoughts by opening a new issue or participating in discussions on existing issues.</p> </li> <li> <p>Submit Pull Requests: If you'd like to contribute code changes, bug fixes, or new features, you can submit a pull request. Follow the guidelines below to ensure a smooth review and merge process.</p> </li> </ol>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<p>To set up a development environment for EsTranslator, follow these steps:</p> <ol> <li>Install Apertium:</li> </ol> <pre><code>wget https://apertium.projectjj.com/apt/install-nightly.sh -O - | sudo bash\nsudo apt install apertium-all-dev\n</code></pre> <ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/icij/es-translator.git\n</code></pre> <ol> <li>Install the required dependencies:</li> </ol> <pre><code>cd es-translator\nmake install\n</code></pre> <ol> <li>Run tests to verify the setup:</li> </ol> <pre><code>make test\n</code></pre>"},{"location":"contributing/#development-commands","title":"Development Commands","text":"<p>The project uses a Makefile for common development tasks. Here's a reference of available commands:</p>"},{"location":"contributing/#code-quality","title":"Code Quality","text":"Command Description <code>make lint</code> Run ruff linter to check for code issues <code>make lint-fix</code> Automatically fix linting issues where possible"},{"location":"contributing/#testing","title":"Testing","text":"Command Description <code>make test</code> Run the test suite with pytest"},{"location":"contributing/#documentation","title":"Documentation","text":"Command Description <code>make serve-doc</code> Start a local documentation server for preview <code>make publish-doc</code> Deploy documentation to GitHub Pages"},{"location":"contributing/#building-cleaning","title":"Building &amp; Cleaning","text":"Command Description <code>make install</code> Install project dependencies via Poetry <code>make clean</code> Remove build artifacts, cache files, and compiled Python files"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":"<p>A typical development workflow looks like:</p> <pre><code># 1. Make your changes to the code\n\n# 2. Run linting to check for issues\nmake lint\n\n# 3. Fix any auto-fixable issues\nmake lint-fix\n\n# 4. Run tests to ensure nothing is broken\nmake test\n\n# 5. Preview documentation changes (if applicable)\nmake serve-doc\n</code></pre>"},{"location":"contributing/#code-contribution-guidelines","title":"Code Contribution Guidelines","text":"<p>When contributing code changes, please adhere to the following guidelines:</p> <ul> <li>Fork the repository and create a new branch for your changes.</li> <li>Ensure your code follows the existing code style and conventions.</li> <li>Run <code>make lint</code> to check for linting issues before committing.</li> <li>Write clear and concise commit messages. We recommend using conventional commits.</li> <li>Include tests to cover your changes and ensure they pass.</li> <li>Update documentation as necessary.</li> <li>Submit a pull request to the <code>master</code> branch of the main repository.</li> </ul>"},{"location":"contributing/#license","title":"License","text":"<p>By contributing to the EsTranslator project, you agree that your contributions will be licensed under the MIT License. You retain the copyright to your contributions.</p>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>We expect all contributors to follow the Code of Conduct when contributing to EsTranslator.</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#choosing-an-interpreter","title":"Choosing an Interpreter","text":"<p>EsTranslator supports two translation backends (interpreters):</p> Feature Argos (default) Apertium Type Neural Machine Translation Rule-based Machine Translation Quality Generally higher quality Good for related languages Speed Slower (uses ML models) Faster Offline Yes (downloads models) Yes (uses system packages) Languages ~30 languages 40+ language pairs Intermediary Not supported Supported Installation Automatic via pip Requires system packages"},{"location":"usage/#when-to-use-argos","title":"When to use Argos","text":"<ul> <li>You need high-quality translations</li> <li>You're translating between common language pairs</li> <li>You don't need intermediary language support</li> </ul>"},{"location":"usage/#when-to-use-apertium","title":"When to use Apertium","text":"<ul> <li>You're translating between related languages (e.g., Spanish-Portuguese)</li> <li>You need intermediary language support for indirect translations</li> <li>You need faster translation speed</li> <li>You're working with less common language pairs</li> </ul> <p>To list available Apertium language pairs:</p> <pre><code>es-translator-pairs --local   # Show locally installed pairs\nes-translator-pairs           # Show all available pairs (remote)\n</code></pre>"},{"location":"usage/#commands","title":"Commands","text":""},{"location":"usage/#es-translator","title":"<code>es-translator</code>","text":"<p>This is the primary command from EsTranslator to translate documents.</p> <pre><code>Usage: es-translator [OPTIONS]\n\nOptions:\n  -u, --url TEXT                  Elasticsearch URL\n  -i, --index TEXT                Elasticsearch Index\n  -r, --interpreter TEXT          Interpreter to use to perform the\n                                  translation\n  -s, --source-language TEXT      Source language to translate from\n                                  [required]\n  -t, --target-language TEXT      Target language to translate to  [required]\n  --intermediary-language TEXT    An intermediary language to use when no\n                                  translation is available between the source\n                                  and the target. If none is provided this\n                                  will be calculated automatically.\n  --source-field TEXT             Document field to translate\n  --target-field TEXT             Document field where the translations are\n                                  stored\n  -q, --query-string TEXT         Search query string to filter result\n  -d, --data-dir PATH             Path to the directory where the language\n                                  model will be downloaded\n  --scan-scroll TEXT              Scroll duration (set to higher value if\n                                  you're processing a lot of documents)\n  --dry-run                       Don't save anything in Elasticsearch\n  -f, --force                     Override existing translation in\n                                  Elasticsearch\n  --pool-size INTEGER             Number of parallel processes to start\n  --pool-timeout INTEGER          Timeout to add a translation\n  --throttle INTEGER              Throttle between each translation (in ms)\n  --syslog-address TEXT           Syslog address\n  --syslog-port INTEGER           Syslog port\n  --syslog-facility TEXT          Syslog facility\n  --stdout-loglevel TEXT          Change the default log level for stdout\n                                  error handler\n  --progressbar / --no-progressbar\n                                  Display a progressbar\n  --plan                          Plan translations into a queue instead of\n                                  processing them now\n  --broker-url TEXT               Celery broker URL (only needed when planning\n                                  translation)\n  --max-content-length TEXT       Max translated content length\n                                  (&lt;[0-9]+[KMG]?&gt;) to avoid highlight\n                                  errors(see http://github.com/ICIJ/datashare/\n                                  issues/1184)\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"usage/#es-translator-tasks","title":"<code>es-translator-tasks</code>","text":"<p>This command allows you to run es-translator workers with Celery. This is particularly useful when you need to distribute the translation between different servers:</p> <pre><code>Usage: es-translator-tasks [OPTIONS]\n\n  Starts a Celery worker.\n\nOptions:\n  --broker-url TEXT       Celery broker URL\n  --concurrency INTEGER   Number of concurrent workers\n  --stdout-loglevel TEXT  Change the default log level for stdout error\n                          handler\n  --help                  Show this message and exit.\n</code></pre>"},{"location":"usage/#examples","title":"Examples","text":""},{"location":"usage/#instant-translation","title":"Instant translation","text":"<p>Translates documents from French to Spanish on a local Elasticsearch. The translated field is <code>content</code> (the default).</p> <pre><code>es-translator \\\n  --url \"http://localhost:9200\" \\\n  --index my-index \\\n  --source-language fr \\\n  --target-language es\n</code></pre> <p>Translates documents from French to English on a local Elasticsearch using Apertium:</p> <pre><code>es-translator \\\n  --url \"http://localhost:9200\" \\\n  --index my-index \\\n  --source-language fr \\\n  --target-language en \\\n  --interpreter apertium\n</code></pre> <p>To translate the <code>title</code> field we could do:</p> <pre><code>es-translator \\\n  --url \"http://localhost:9200\" \\\n  --index my-index \\\n  --source-language fr \\\n  --target-language es \\\n  --source-field title\n</code></pre> <p>Translates documents from English to Spanish on a local Elasticsearch using 4 threads:</p> <pre><code>es-translator \\\n  --url \"http://localhost:9200\" \\\n  --index my-index \\\n  --source-language en \\\n  --target-language es \\\n  --pool-size 4\n</code></pre> <p>Translates documents from Portuguese to English, using an intermediary language (Apertium doesn't offer this translation pair):</p> <pre><code>es-translator \\\n  --url \"http://localhost:9200\" \\\n  --index my-index \\\n  --interpreter apertium \\\n  --source-language pt \\\n  --intermediary-language es \\\n  --target-language en\n</code></pre>"},{"location":"usage/#planned-translation","title":"Planned translation","text":"<p>This tools can be use to plan translation (ie. building a list of document to translate) which can be consume by es-translator later, on one or several servers. This can be useful in two cases:</p> <ul> <li>You have a lot of big documents and EsTranslator loose the search context because it takes too long to translate a document</li> <li>You have a lot of documents and want to distribute the translation on several servers</li> </ul> <p>To do so, you will have to follow two steps. We start with planning the translation:</p> <pre><code>es-translator \\\n  --url \"http://localhost:9200\" \\\n  --broker-url \"redis://redis:6379\" \\\n  --index my-index \\\n  --source-language fr \\\n  --target-language en \\\n  --pool-size 1 \\\n  --plan\n</code></pre> <p>What happends here? You can see we added two parameters to EsTranslator. First, <code>--broker-url</code> which is the URL of the  remote Redis server we use to store the list and distribute it later. Second, <code>--plan</code> which simply tells EsTranslator  to store the list of documents to translate (with all the given command arguments) in the broker.</p> <p>When this command is done, we can proceed to translate from the broker list:</p> <pre><code>es-translator-tasks \\\n  --broker-url \"redis://redis:6379\" \\\n  --concurrency 1\n</code></pre> <p>You can run this command as many server as you want. In practice, we start it directly with a detached Docker container so the task run as a service and can restart automaticaly in case of failure:</p> <pre><code>sudo docker run \\\n  --privileged \\\n  --interactive \\\n  --tty \\\n  --detach \\\n  --restart on-failure \\\n  --name es-translator-tasks \\\n  icij/es-translator es-translator-tasks \\\n    --broker-url \"redis://redis:6379\" \\\n    --concurrency 1\n</code></pre>"},{"location":"usage/#configuration-options","title":"Configuration Options","text":""},{"location":"usage/#environment-variables","title":"Environment Variables","text":"Variable Description Default <code>REDIS_URL</code> Redis URL for Celery broker <code>redis://localhost:6379/0</code>"},{"location":"usage/#performance-tuning","title":"Performance Tuning","text":"<ul> <li><code>--pool-size</code>: Increase for faster translation on multi-core systems. Each worker process handles one document at a time.</li> <li><code>--scan-scroll</code>: Increase (e.g., <code>10m</code>, <code>30m</code>) when processing large datasets to prevent Elasticsearch scroll timeout.</li> <li><code>--max-content-length</code>: Limit translated content length to avoid Elasticsearch highlighting issues. Accepts values like <code>1M</code>, <code>10M</code>, <code>1G</code>.</li> <li><code>--throttle</code>: Add delay between translations (in ms) to reduce load on Elasticsearch.</li> </ul>"},{"location":"usage/#troubleshooting","title":"Troubleshooting","text":""},{"location":"usage/#common-issues","title":"Common Issues","text":""},{"location":"usage/#the-pair-is-not-available","title":"\"The pair is not available\"","text":"<p>This error occurs when the requested language pair is not supported by the interpreter.</p> <p>For Argos:</p> <ul> <li>Check available pairs: Argos automatically downloads required language models</li> <li>Ensure you have internet connectivity for the first run</li> </ul> <p>For Apertium:</p> <ul> <li>List available pairs: <code>es-translator-pairs</code></li> <li>Try using an intermediary language: <code>--intermediary-language es</code></li> </ul>"},{"location":"usage/#elasticsearch-scroll-context-timeout","title":"Elasticsearch scroll context timeout","text":"<p>When processing large datasets, you may see errors about lost scroll context.</p> <p>Solutions:</p> <ol> <li>Increase scroll duration: <code>--scan-scroll 30m</code></li> <li>Use planned translation mode with <code>--plan</code> to process documents individually</li> <li>Reduce <code>--pool-size</code> to process fewer documents simultaneously</li> </ol>"},{"location":"usage/#memory-issues-with-large-documents","title":"Memory issues with large documents","text":"<p>Large documents can cause memory issues, especially with Argos.</p> <p>Solutions:</p> <ol> <li>Limit content length: <code>--max-content-length 10M</code></li> <li>Reduce <code>--pool-size</code> to limit concurrent translations</li> <li>Use Apertium interpreter which is more memory-efficient</li> </ol>"},{"location":"usage/#translation-taking-too-long","title":"Translation taking too long","text":"<p>Solutions:</p> <ol> <li>Increase <code>--pool-size</code> for parallel processing</li> <li>Use Apertium interpreter (faster but may have lower quality)</li> <li>Filter documents with <code>--query-string</code> to process only what's needed</li> <li>Use <code>--dry-run</code> first to test without saving</li> </ol>"},{"location":"usage/#docker-container-cannot-connect-to-elasticsearch","title":"Docker container cannot connect to Elasticsearch","text":"<p>When running es-translator in Docker, it may not be able to reach Elasticsearch on <code>localhost</code>.</p> <p>Solutions:</p> <ol> <li>Use host network mode: <code>docker run --network host ...</code></li> <li>Use the host's IP address instead of <code>localhost</code></li> <li>Use Docker's special DNS name: <code>host.docker.internal</code> (on Docker Desktop)</li> </ol>"},{"location":"usage/#debug-mode","title":"Debug Mode","text":"<p>To enable detailed logging for troubleshooting:</p> <pre><code>es-translator \\\n  --stdout-loglevel DEBUG \\\n  --url \"http://localhost:9200\" \\\n  --index my-index \\\n  --source-language fr \\\n  --target-language en\n</code></pre>"},{"location":"usage/#dry-run-mode","title":"Dry Run Mode","text":"<p>Test your configuration without modifying Elasticsearch:</p> <pre><code>es-translator \\\n  --dry-run \\\n  --url \"http://localhost:9200\" \\\n  --index my-index \\\n  --source-language fr \\\n  --target-language en\n</code></pre>"}]}